IP协议头部结构
    版本号
    头部长度
    服务类型
    总长
    标识标志
    片偏移量
    生存时间
    协议
    头部校验和
    源IP地址和目标IP地址

TCP协议头部结构
    源端口号
    目标端口号
    序列号
    确认号
    头部长度
    保留位
    标志位
    窗口大小
    校验和
    紧急指针

UDP协议头部结构
    源端口号
    目标端口号
    总长度
    校验和

HTTP请求分为4个部分：请求行，请求头、空行、请求正文
请求行分为：请求方法、URL、版本号
请求头包含很多信息，都是键值对形式，包括cookie，语言、压缩方式等

HTTP响应同样是4个部分：响应行、响应头、空行、响应正文
响应行：版本号、状态码、状态码的描述
响应头同样也是键值对，内容类型，日期等

TCP和UDP区别：
TCP面向连接，UDP不需要连接
TCP一对一，UDP支持一对一、一对多、多对多
TCP保证可靠性，UDP不保证可靠性
TCP拥有拥塞控制和流量控制，UDP没有
TCP头部较大，UDP较小且固定长度

TCP保证可靠性的方法：
随机序列
确认应答 (ACK)
超时重传
连接管理 (三次握手四次挥手)
流量控制 (根据接收端的处理能力，来决定发送端的发送速度)
滑动窗口 (接收数据段使用的窗口大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的大小，达到流量控制的目的)
拥塞控制 (慢开始，拥塞避免，快重传，快回复)

UDP如何实现可靠传输：
参考TCP，在应用层实现确认机制，重传机制，窗口确认机制

HTTP的状态码
1XX：信息类，100，正在处理请求
2XX：成功类，200 OK 成功处理请求
3XX：重定向类，301永久移动，302临时移动
4XX：请求错误，400请求语法错误，404未找到，405请求方式不支持
5XX：服务器错误
    500服务器内部错误
    502网关错误，网关从上游服务器中接受到的响应是无效的，是指上游服务器自己执行超时或者没有按照协议约定来返回数据
    503服务不可用(服务器停机维护或者超载，暂时状态)
    504网关超时，是指超过了网关自己的时间，没有建立与服务器之间的联系

HTTPS
SSL/TCL公钥私钥交换过程：
服务器把自己的公钥登录至CA
CA将服务器的公钥使用散列技术生成哈希值，生成一个摘要
CA使用自己的私钥加密这个摘要生成数字签名附在证书下面，发送给服务器
服务器将这个证书发送给客户端
客户端拿到证书后，使用CA的公钥，解密数字签名，获得CA生成的摘要
客户端对证书内的数据，也就是服务器的公钥，做相同的散列处理，得到摘要，与之前签名中解码得到的摘要对比来验证身份
验证通过后，客户端使用服务器的公钥对数据加密后发送
服务器使用私钥进行解密

HTTP1.0是短连接，在一次http连接完成后就会断开，需要重复建立连接十分耗费时间和资源
1.1是长连接，完成一次连接后tcp连接还会保留一段时间，如果需要进行新的http连接直接连接即可，可以复用
HTTP的长连接和短连接本质上就是tcp的长连接和短连接

HTTP2.0加入了多路复用技术，可以一个连接发送多个请求，头部压缩，服务器推送，可以对一个客户端请求发送多个响应，加快了响应速度
HTTP3.0基于UDP协议

TCP的保活机制是由一个保活计时器实现的，当计时器被激发，会发送一个保活检测报文，另一端接收报文后会响应一个ACK
如果收到响应就重置计时器，没有收到，则经过一个时间间隔后再次发送，依次类推直到达到保活探测数，此时，中断连接

IP地址可以分为
1.五类IP
    (IP地址一共32位，分别以1/2，1/4，1/8, 1/16分段)
    A类：0.0.0.0 - 127.255.255.255
    B类：128.0.0.0 - 191.255.255.255
    C类：192.0.0.0 - 223.255.255.255
    D类：224.0.0.0 - 239.255.255.255
    E类：240.0.0.0 - 255.255.255.255
2.特殊用途IP，特殊源、换回、广播
3.私有IP

websocket
websocket能够实现全双工通信，基于tcp，
http是单向的且每次发送数据时要包含大量头信息
websocket通过第一次建立tcp连接之后，不需要发送header就可以交换数据

用户态和内核态之间的切换
1.系统调用，是用户态程序主动向系统申请切换
2.异常，在执行用户态的程序时，发生了某些不可知的异常，这时会切换到处理此异常的内核态程序，完成了切换
3.中断，外围设备向CPU发送中断信号，这时CPU会停止执行下一条指令而去执行处理中断信号的程序，如果之前执行的用户态程序，这样就自然完成了用户态到内核态的转换

32位地址空间高位的是内核空间，低位的是用户空间

五种IO模型
同步阻塞IO
同步非阻塞IO
IO多路复用，(select poll epoll 监视文件描述符(fd))
异步IO，指异步非阻塞IO
信号驱动IO

IO多路复用
select，用一个集合将所有的fd全部拷贝，然后进行轮询，且集合大小有限
poll，将select的集合替换为链表，因此大小没有限制
epoll，事件驱动，采用回调机制，避免了不断复制的问题，且支持很高的同时连接数，支持水平触发和边缘触发

水平触发：只要一个文件描述符就绪，就会触发通知，会重触发
边缘触发：当描述符从未就绪到就绪会通知一次，后续就不会再通知，效率更高，减少了被冲触发的次数

操作系统IO的过程：
1.IO中断，外部存储设备通过IO中断通知CPU，CPU将数据拷贝到内核缓冲区，然后拷贝到用户缓冲区，每次都有上下文切换开销及CPU拷贝的时间
2.通过DMA(Direct Memory Access)，CPU通知DMA控制器拷贝外部存储设备数据到内核缓冲区，完成后再通知CPU拷贝到用户缓冲区减轻了CPU的负担

数据库的MVCC主要在RR级别和RC级别下实现(RU级别没有解决任何一个问题，串行化直接加表锁)
主要是实现非锁定读，核心思想是对每个连接数据库的用户，查询操作读到的都是快照，写入操作在事务提交之前对于其他用户来说都是不可见的

通过数据库的隐藏字段，
DATA_TRX_ID：标记最近更新这条记录的事务id
DATA_ROLL_PTR：指向该条记录的undo log记录
DB_ROW_ID：如果没有建立索引，则有默认索引
DELETE_BIT：标识该条数据有没有被删除

每次事务修改数据时：update时候是当前读
使用排它锁锁定该行
记录redo log
将修改前的值拷贝到undo log
修改当前行的值，填写事务编号，让回滚指针指向undo log中修改前的行

在RC级别下，读事务每次都读取距离undo log最近的那个版本
在RR级别下，每次都读取指定的版本

在RR级别下，快照读ReadView在第一次执行普通select查询时生成，可重复读实际上就是ReadView的重复使用，也就解决了幻读的问题
在RC级别下，每次读时都会产生一个ReadView

每次读取操作时，只能读取到select事务版本之前创建的行，也就是创建版本号小于当前事务版本号的行
以及在当前事务之后删除的行，也就是删除版本号大于当前事务版本号的行

MySQL锁的分类：
基于属性：共享锁、排它锁
基于粒度：表锁、行锁(记录锁、间隙锁)
基于状态：意向共享锁、意向排它锁

共享锁就是读锁，也叫S锁，一个事物对数据加上S锁之后，其他事物只能对该数据加读锁
排它锁就是写锁，也叫X锁，当一个事物对数据加上X锁后，其他事物不能对该数据添加任何锁

表锁粒度大，对整张表加锁，行锁粒度小，并发度更高
间隙锁可以解决幻读问题

数据库四大特性ACID分别使用什么方法实现？
A原子性，通过undo log，主要能实现事务回滚
I隔离性，主要通过锁和mvcc
D持久性，主要通过redo log，当数据库服务器意外崩溃或者宕机后，保证已经提交的事务，持久化到磁盘中
C一致性，一致性是目的，AID是手段

MySQL的索引：
主键索引、唯一索引、普通索引、全文索引

索引为什么要用B+树实现
1.提升查询效率，尽可能少的从磁盘读取数据
2.保证读取的数据足够有效所以要分块读取
3.磁盘和内存进行交互以页为单位，一般读取页的整数倍，innoDB默认读取16kb
4.二叉树等有个致命缺点就是节点只有2个，插入多个数据时会导致变深，查询效率下降
5.因此要使用多叉树，同时因为数据都是有序的，因此考虑B树和B+树
6.B树不能保证查询每个数据效率都一致，并且每个块都会存储索引和实际数据，实际数据占用空间，造成树的分支减少，也就会增加树的深度

自增主键的优点：
1.自动编号，速度快，按顺序存放，对于检索十分有利
2.数字型，空间小，易于排序，传递也方便
3.不担心主键重复
缺点：
1.因为自增，在手动要插入指定ID的记录时会十分麻烦，当有多个系统需要数据导入时，很难保证原系统与新系统的id不发生冲突
2.如果经常合并表，就可能出现主键重复的情况

数据库三大范式
1.无重复的列
2.属性完全依赖于主键
3.属性不依赖于其他非主属性

Java泛型的实现原理：类型擦除，使用Object等来替代泛型，在实现具体类型方法或者成员变量时使用强转保证多态特性

解决java中传统非线程安全的容器可以使用Collections.synchronized + 容器类型(Map, Set, List)方法

Java虚拟机运行时的数据区：
线程隔离的数据区：虚拟机栈，本地方法栈，程序计数器
线程共享的数据区：方法区，堆

JDK1.8，静态变量和字符串常量池存放在堆中，运行时常量池存放在方法区中

Java中的引用：
1.强引用，平常使用的都是强引用，可以直接访问目标对象，在任何时候都不会被回收
2.软引用，比强引用弱一些的引用，只有当堆空间不足时，会回收这个对象，使用场景：回收
3.弱引用，比软引用弱一些，只要发现弱引用，不管空间是否足够，都会在下次回收时回收，使用场景：回收
4.虚引用，最弱的，和没有引用几乎是一样的，随时都可以被垃圾回收器回收，使用场景：对象回收的跟踪

Java类加载过程：
1.加载：通过全限定名获取二进制字节流，将这个类的静态存储结构转化为方法去的运行时数据结构，在内存中生成一个代表这个类的对象
2.验证：确保字节流中的信息不回危害到虚拟机
3.准备：为类的静态变量分配内存，并初始化为默认值(注意区分这里的默认值是说这类型的默认值，并不是用户指定的)
4.解析：将常量池内的符号引用替换为直接引用
5.初始化：将主导权移交给应用程序，包括静态字段赋值的操作